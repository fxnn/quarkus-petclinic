import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.annotation.Annotation;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.Instant;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.dialect.Dialect;
import org.hibernate.dialect.PostgreSQL10Dialect;
import org.hibernate.tool.hbm2ddl.SchemaExport;
import org.hibernate.tool.hbm2ddl.SchemaExport.Action;
import org.hibernate.tool.schema.TargetType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generates a SQL schema from the Entities defined in the code.
 *
 * <p>This generates a SQL file, which can be used during creation of SQL migration scripts: simply
 * use the diff of that generated SQL file as template.
 *
 * <p>Note, that you must currently provide the exact package names where the entities reside. This
 * might be improved in future by some scanning mechanism.
 */
public class GenerateSqlCommand {

  public static final List<String> INPUT_ENTITY_PACKAGE_NAMES =
      List.of("com.github.acme.quarkus.petclinic.model");
  public static final String OUTPUT_SQL_FILE = "src/test/resources/db-create-all.sql";
  public static final Class<? extends Dialect> CONFIG_DB_DIALECT = PostgreSQL10Dialect.class;

  private static final Logger LOG = LoggerFactory.getLogger(GenerateSqlCommand.class);

  // HINT: allow catching generic exceptions to allow for properly handling any exceptions
  @SuppressWarnings("PMD.AvoidCatchingGenericException")
  public static void main(String[] args) {
    try {

      Map<Object, Object> settings = Map.of("hibernate.dialect", CONFIG_DB_DIALECT.getName());

      prepareOutputFile(OUTPUT_SQL_FILE);
      Metadata metadata = collectMetadata(settings, INPUT_ENTITY_PACKAGE_NAMES);
      exportSchema(metadata);

    } catch (Exception ex) {
      LOG.error("Could not export schema due to exception", ex);
    }
  }

  private static void prepareOutputFile(String fileName) throws IOException {
    try (PrintWriter writer =
        new PrintWriter(
            Files.newBufferedWriter(
                Path.of(fileName),
                StandardOpenOption.TRUNCATE_EXISTING,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE))) {
      writer.println("--");
      writer.println("-- script to create all entities in this project");
      writer.println("-- generated by " + GenerateSqlCommand.class.getName());
      writer.println("-- generated at " + Instant.now());
      writer.println("--");
      writer.println();
    }
  }

  private static void exportSchema(Metadata metadata) {
    var schemaExport = new SchemaExport();
    schemaExport.setHaltOnError(true);
    schemaExport.setFormat(true);
    schemaExport.setDelimiter(";");
    schemaExport.setOutputFile(OUTPUT_SQL_FILE);
    schemaExport.execute(EnumSet.of(TargetType.SCRIPT), Action.CREATE, metadata);
  }

  private static Metadata collectMetadata(Map<Object, Object> settings, List<String> packageNames)
      throws URISyntaxException, IOException, ClassNotFoundException {
    var registry = new StandardServiceRegistryBuilder().applySettings(settings).build();

    var metadataSources = new MetadataSources(registry);
    for (String packageName : packageNames) {
      addEntityClassesFromPackage(metadataSources, packageName);
    }

    var metadata = metadataSources.buildMetadata();
    LOG.info(
        "Created Metadata with tables={}",
        metadata.getDatabase().getDefaultNamespace().getTables());

    return metadata;
  }

  private static void addEntityClassesFromPackage(
      MetadataSources metadataSources, String packageName)
      throws ClassNotFoundException, IOException, URISyntaxException {
    for (Class<?> clazz : getEntityClassesFromPackage(packageName)) {
      metadataSources.addAnnotatedClass(clazz);
    }
  }

  /** Based upon <a href="https://stackoverflow.com/a/41554193/3281722">Stack Overflow</a> */
  public static List<Class<?>> getEntityClassesFromPackage(String packageName)
      throws ClassNotFoundException, IOException, URISyntaxException {
    List<String> classNames = getClassNamesFromPackage(packageName);
    List<Class<?>> classes = new ArrayList<>();
    for (String className : classNames) {
      Class<?> cls = Class.forName(packageName + "." + className);
      Annotation[] annotations = cls.getAnnotations();

      for (Annotation annotation : annotations) {
        if (annotation instanceof javax.persistence.Entity) {
          classes.add(cls);
        }
      }
    }

    return classes;
  }

  /** Based upon <a href="https://stackoverflow.com/a/41554193/3281722">Stack Overflow</a> */
  private static List<String> getClassNamesFromPackage(String packageName)
      throws URISyntaxException {
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    List<String> names = new ArrayList<>();

    var packagePath = packageName.replace(".", "/");
    URL packageURL = classLoader.getResource(packagePath);
    if (packageURL == null) {
      throw new IllegalStateException("cannot get package URL for '" + packageName + "'");
    }

    var folderPath = packageURL.toURI().getPath();
    var folder = new File(folderPath);
    var files = folder.listFiles();
    if (files == null) {
      throw new IllegalStateException("cannot load files for folder '" + folderPath + "'");
    }

    for (File file : files) {
      String name = file.getName();
      name = name.substring(0, name.lastIndexOf('.')); // remove ".class"
      names.add(name);
    }

    return names;
  }
}
